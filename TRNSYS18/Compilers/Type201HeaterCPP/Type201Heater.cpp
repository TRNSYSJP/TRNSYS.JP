#include <cmath>
#include <fstream>
#include <algorithm>

#include "TRNSYS.h" //TRNSYS acess functions (allow to acess TIME etc.) 
// Object: Noname
// Simulation Studio Model: Type201Heater
// 

// Author: 
// Editor: 
// Date:	 12ŒŽ 02, 2019
// last modified: 12ŒŽ 02, 2019
// 
// 
// *** 
// *** Model Parameters 
// *** 
//			Cp	kJ/kg.K [-Inf;+Inf]

// *** 
// *** Model Inputs 
// *** 
//			m	kg/hr [-Inf;+Inf]
//			Tset	C [-Inf;+Inf]
//			Tin	C [-Inf;+Inf]

// *** 
// *** Model Outputs 
// *** 
//			Q	kJ/hr [-Inf;+Inf]

// *** 
// *** Model Derivatives 
// *** 

// (Comments and routine interface generated by TRNSYS Simulation Studio)
//************************************************************************


extern "C" __declspec(dllexport) void TYPE201(void)
{
	//Variable Declarations
    
//    PARAMETERS
      double Cp;

//    INPUTS
      double m;
      double Tset;
      double Tin;

//	  OUTPUTS
	  double Q;

	double Timestep, Time, tin, tout, tset, ton, qmax, qaux, flow, cp, htreff, qfluid, outval, val;
	int igam, index, CurrentUnit, CurrentType;
	char type[20];
	char message[400];

	//Get the Global Trnsys Simulation Variables
	Time = getSimulationTime();
	Timestep = getSimulationTimeStep();
	CurrentUnit = getCurrentUnit();
	CurrentType = getCurrentType();

	//Set the Version Number for This Type
	if (getIsVersionSigningTime())
	{
		int v = 17;
		setTypeVersion(&v);
		return;
	}

	//Do All of the Last Call Manipulations Here
	if (getIsLastCallofSimulation())
	{
		return;
	}

	//Perform Any "End of Timestep" Manipulations That May Be Required
	if (getIsEndOfTimestep()) 
	{
        //TODO: write SSR values, if any
        //if (getIsIncludedInSSR())
		//{
		//	double outval=42;
		//	index = 1;
		//	updateReportIntegral(&index, &outval);
        //  ...
        //}
	}

	//Do All of the "Very First Call of the Simulation Manipulations" Here
	if (getIsFirstCallofSimulation())
	{
		//Tell the TRNSYS Engine How This Type Works
		int npar = 1;
		int nin = 3;
		int nder = 0;
		int nout = 1;
		int mode = 1;
		int staticStore = 0;
		int dynamicStore = 0;

		setNumberofParameters(&npar);
		setNumberofInputs(&nin);
		setNumberofDerivatives(&nder);
		setNumberofOutputs(&nout);
		setIterationMode(&mode);
		setNumberStoredVariables(&staticStore, &dynamicStore);

		return;
	}

	//Do All of the "Start Time" Manipulations Here - There Are No Iterations at the Intial Time
	if (getIsStartTime())
	{

		//Read in the Values of the Parameters from the Input File
		index = 1; Cp = getParameterValue(&index);


		//TODO: Check the Parameters for Problems
		//if (p < 0.)
		//{
		//	index = 1;
		//	strcpy_s(type, "FATAL");
		//	strcpy_s(message, "The heater capacity must be positive.");
		//	foundBadParameter(&index, type, message, (size_t)strlen(type), (size_t)strlen(message));
		//}
        
		//Read in the Values of the Inputs from the Input File
		index = 1; m = getInputValue(&index);
		index = 2; Tset = getInputValue(&index);
		index = 3; Tin = getInputValue(&index);


		//Set the Initial Values of the Outputs
		index = 1; val = 0.0; setOutputValue(&index, &val); // Q


		//TODO: Initialize SSR report variables, if any
		//if (getIsIncludedInSSR())
		//{
		//	index = 1;
		//	char desc[100], unit1[5], unit2[5];
		//	strcpy_s(desc, "Energy to Fluid");
		//	strcpy_s(unit1, "kJ/h");
		//	strcpy_s(unit2, "kJ");
		//	initReportIntegral(&index, desc, unit1, unit2, (size_t)strlen(desc), (size_t)strlen(unit1), (size_t)strlen(unit2));
        //  ...        
		//}

		return;

	}

//---------------------------------------------------------------------------------------------------------------------- -
	//ReRead the Parameters if Another Unit of This Type Has Been Called Last
		index = 1; Cp = getParameterValue(&index);



	//Get the Current Inputs to the Model
		index = 1; m = getInputValue(&index);
		index = 2; Tset = getInputValue(&index);
		index = 3; Tin = getInputValue(&index);


//---------------------------------------------------------------------------------------------------------------------- -

	//Perform All of the Calculations Here
	//TODO:add algorithm

		Q = m * Cp * (Tset - Tin);

    //double result1=0.0;
	//index = 1;
	//setOutputValue(&index, &result1);
		index = 1; setOutputValue(&index, &Q);

    return;
}